<html><head><title>Level 7 Monitor</title></head><body>

<h1>LEVEL SEVEN DOCUMENTATION</h1>

<h2>T.C.L. SOFTWARE 1979.</h2>

<p>This document is believed to be correct and every effort has been made to ensure the information contained herein is accurate. However, no responsibility can be accepted for inaccuracies or omissions.</p>

<p>LEVEL SEVEN is a new and very powerful software package for the TRITON computer system. It consists of a 2k monitor with 24 functions and an 8k extended BASIC.</p>

<p>AVAILABLE EXCLUSIVELY FROM:<br>
TRANSAM COMPONENTS LTD.<br>
12 CHAPEL STREET, LONDON, NW1<br>
TEL: 402 8137</p>

<h1>LEVEL SEVEN FIRMWARE</h1>

<h2>LEVEL SEVEN BASIC &amp; MONITOR</h2>

<h2>PAUL BAXTER (TRANSAM)</h2>

<h1>LEVEL SEVEN MONITOR</h1>

<p>The first section of this documentation deals with the operation and application of the 7.2 monitor, the second section is devoted to the extended BASIC.</p>

<h2>INTRODUCTION</h2>

<p>The Triton level seven monitor is a 2k operating program intended to carry out essential management routines and provide the user with a powerful set of commands for entering, debugging, and running machine code programs. It also has single keystroke vectors to TRAP for more extensive assembly language writing and to level seven BASIC for programming in the high level language.</p>


<h2>GETTING IT GOING </h2>

<p>The level seven firmware comes in 10x2708 type EPROMS, the monitor is supplied in 2 EPROMS marked MONITOR 7.2 A and MONITOR 7.2 B. The A ROM is inserted into the socket on the main board for IC21 which is the socket furthest from the expansion socket, the B ROM is placed in the socket for IC24 (the one nearest to the expansion socket). Note: Users with a parallel version will have the 7.2A chip replaced with one marked 7.2P. This goes in the same position as the A.</p>

<p>The level seven BASIC is in 8x2708 EPROMS and needs to be fitted in an EPROM card on the motherboard. The card may be placed at any position on the motherboard, but the jumper (or switch) should be set at the topmost position (block 7) which is the position nearest to the plug on the card. The EPROMs are placed in the card starting BASIC 7.2 A in the position of IC7 (top right hand socket), BASIC B goes in IC8 next to it, BASIC C goes below A etc.</p>

<p>Take care when inserting the ROMs as it is very easy to bend the pins when inserting. Check the ROMs again, then plug the ROM card into the motherboard and switch on. The welcome message below should be displayed.</p>

<pre>
TRITON V7.2
END:XXXX (XXXX is a hexadecimal address)
FUNCTION?  P Q J E R C G A D U H L F T S I O W M V X N Z K
</pre>

<p>Triton is now waiting for you to enter one of the letters shown in the FUNCTION message. The message END:XXXX is to inform the user of the amount of memory on-line at power-up. This is the amount of memory that will be assumed until another reset occurs. It is important to power up the motherboard at the same time or before the main board as otherwise the Triton will only assume memory on the main board. At power-on Triton performs a non-destructive memory test to determine how much memory is available. This means that RESET can be pressed at any time without the fear of destroying the contents of memory. This also means that memory will contain a random pattern at switch on. If it is desired to set memory to a certain value refer to the E function.</p>

<p>XXXX is the address at which memory failed. This will be 2000 with the on-board ram or 4000 with one ram card in position 1 on the motherboard and so on.</p>

<p>Reference is made in following sections to 'The main loop'. This is the waiting section of the monitor. Triton prints the FUNCTION message and awaits an entry from the user.</p>

<h2>USING TRITON</h2>

<p>The functions and their use are described below; it is recommended that these are studied carefully if you are used to any of the previous monitors as there are some differences in operation. After the description is an example of the monitor in action. This should enable you to take full advantage of the many features of the level seven monitor.</p>

<h3>P - Program</h3>

<p>This function allows entry and displaying of the content of memory in hexadecimal (shortened to hex) - its main use is for the entry and checking of small blocks of memory. For longer programs, the Q function is more suited.</p>

<p>To call this function, type P. The message 'START:' will be printed below and the computer waits for you to enter a start address for programming. The address is entered in Hex and may be up to 4 characters long. If more than 4 characters are entered the last four entered are used; if less than 4 are entered leading zeros are appended (e.g. If 23 is entered the address 0023 is used). If an invalid character is entered it terminates the address (e.g. if X is entered the address will be 0000).</p>

<p>If during entry, a mistake is made, the character can be deleted by use of the DEL key. The character can then be re-typed and when the new address is correct press the RETURN key and the address entered will be displayed below together with the data in that location in the form: 0000 31</p>

<p>Note that both the address and data are in hex. The user may then enter new data, or retain the old data. To retain the data in that location press RETURN; the computer will then step to the next location in memory, displaying it as before. If you wish to step back one location the up-arrow (&uarr;) should be entered as the first character ( shift (RS) ). If the value in that location is to be changed, it should be entered followed by RETURN or up-arrow (depending on whether you wish to step forward or back). If the data is only 1 character a leading 0 is added if 2 characters or more the last 2 characters are used. This method for entering addresses and data applies to the other functions with the exception of Q (see next section). To exit from the program mode (or, indeed from any function) enter Control-C. (The CTRL key held whilst C is pressed). The FUNCTION message will be displayed.</p>

<h3>Q - Quick Program</h3>

<p>This function has been included as a tool primarily for the entry of programs or strings of data and is not intended for changing single bytes. To enter the function from the main monitor loop type 'Q' - TRITON will respond with 'START:' You can then enter an address as detailed above. When the 'return' key is pressed the monitor will respond as in the program mode and you may step backwards or forwards as above. The difference comes in entering data - instead of having to press 'return' between bytes, the monitor will enter and step forward as soon as two digits have been entered - in addition invalid characters (not 0-9 or A-F) will be ignored. If a valid character is typed incorrectly you cannot use the 'Del' key - instead you must press 'return' followed by '^' to go back to that location again. To exit from the function type control C as above. You may step forward or back through memory after entering the first digit without altering the content of that location.</p>

<p>BOOKS ON ASSEMBLY LANGUAGE PROGRAMMING AND BASIC AVAILABLE FROM TRANSAM</p>

<table>
<tr><td><u>REF. NO</u></td><td><u>TITLE</u></td><td><u>PRICE</u></td></tr>
<tr><td>CB98</td><td>A QUICK LOOK AT BASIC</td><td>£10.95</td></tr>
<tr><td>CB41</td><td>ADVANCED BASIC</td><td>£6.00</td></tr>
<tr><td>CB97</td><td>ACCENT ON BASIC</td><td>£4.95</td></tr>
<tr><td>CB163</td><td>BASIC PRIMER</td><td>£6.95</td></tr>
<tr><td>CB65</td><td>BASIC COMPUTER GAMES</td><td>£5.50</td></tr>
<tr><td>CB95</td><td>BASIC - A UNIT FOR SECONDARY SCHOOLS</td><td>£4.45</td></tr>
<tr><td>CB40</td><td>BASIC BASIC</td><td>£6.50</td></tr>
<tr><td>B18</td><td>BASIC A HANDS-ON METHOD</td><td>£7.78</td></tr>
<tr><td>B22</td><td>BASIC FROM THE GROUND UP</td><td>£6.60</td></tr>
<tr><td>B24</td><td>BASIC WITH BUSINESS APPLICATIONS</td><td>£9.74</td></tr>
<tr><td>B25</td><td>BASIC WITH STYLE (PROGRAMMING PROVERBS)</td><td>£4.07</td></tr>
<tr><td>B26</td><td>BASIC WORKBOOK</td><td>£4.39</td></tr>
<tr><td>B206</td><td>BITS 8080 PROGRAMMER CODING PAD</td><td>£1.50</td></tr>
<tr><td>CB37</td><td>BEGINNING BASIC</td><td>£6.50</td></tr>
<tr><td>CB150</td><td>PROGRAMS THAT WORK (IN BASIC)</td><td>£3.15</td></tr>
<tr><td>B79</td><td>GUIDED TOUR OF PROGRAMMING IN BASIC</td><td>£4.13</td></tr>
<tr><td>CB70</td><td>GAME PLAYING WITH BASIC</td><td>£5.50</td></tr>
<tr><td>CB36</td><td>INSTANT BASIC</td><td>£7.20</td></tr>
<tr><td>CB161</td><td>MORE BASIC COMPUTER GAMES</td><td>£5.50</td></tr>
<tr><td>CB168</td><td>MICROSOFT BASIC</td><td>£6.75</td></tr>
<tr><td>CB126</td><td>PIMS (Personal Information Management Systsem) (BASIC)</td><td>£6.81</td></tr>
<tr><td>CB28</td><td>STEP BY STEP INTRODUCTION TO 8080 SYSTEMS</td><td>£6.45</td></tr>
<tr><td>CB39</td><td>SOME COMMON BASIC PROGRAMS</td><td>£6.45</td></tr>
<tr><td>CB48</td><td>SCELBI 8080 GOURMET GUIDE &amp; COOKBOOK</td><td>£7.95</td></tr>
<tr><td>CB96</td><td>TEACHERS' BASIC MANUAL</td><td>£6.45</td></tr>
<tr><td>CB184</td><td>THE LITTLE BOOK OF BASIC STYLE</td><td>£5.25</td></tr>
<tr><td>CB31</td><td>8080 BUGBOOK</td><td>£7.65</td></tr>
<tr><td>CB50</td><td>8080 PROGRAMMING FOR LOGIC DESIGN</td><td>£6.30</td></tr>
<tr><td>CB53</td><td>8080/8085 ASSEMBLY LANGUAGE PROGRAMMING</td><td>£6.95</td></tr>
</table>

<h3>J - Jump to BASIC L7.2</h3>

<p>This function causes a jump to BASIC level seven. This function will respond with the message:</p>

<pre>
BASIC L7.2.
END ADDRESS ?
</pre>

<p>The computer will then wait for you to enter an address in hex at which you wish to stop BASIC using memory, this is used to free memory for use by machine-code subroutines etc. If you wish BASIC to use all memory, enter a RETURN and the message</p>

<pre>
2554 BYTES FREE
READY >
</pre>

<p>will be displayed and the computer is now in BASIC (2554 bytes is the message with 3k of on-board ram). To exit to the monitor enter control-C. If an address less than 1700 or greater than the end of memory is entered, all memory is used. This function must be used before X and will always clear memory whereas X will not.</p>

<h3>E - Erase Memory</h3>

<p>This function is used to initialise a block of memory to any given value. When this function is called up, the computer will request a start address, an end address and a byte value - the start and end addresses are both 4 digit hex-addresses as detailed previously, the byte value is any two digit hex byte. When 'return' has been pressed after entering the byte, the monitor will proceed to fill memory between the two addresses (inclusive) with that byte. When the function is finished the oscillator will sound.</p>

<p>N.B. For correct operation the start address must be below the end address as the byte is written to memory commencing at the 'START': address and incremented until it equals the end address. Therefore if the 'START:' is given at 3000 and the end as 2000 all memory will be set to the value except between 2000 - 3000! This also applies to the S,H,F and N functions.</p>

<h3>R - Register Operation</h3>

<p>When this function is entered the monitor will wait for another key to be pressed to indicate which register operation is required. If the space bar is hit all registers and flags will be displayed - a typical printout is shown below:</p>

<pre>
A  C  B  E  D  L  H  SP   PC
00 10 FF 57 05 57 AO 1468 1647 SAP
</pre>

<p>You will note that the register pairs (HL,DE,BC) are displayed low order byte first - the letters referring to the register PC - Program counter, SP - Stack pointer are printed above. The letters following the program counter represent the flags - if the flag is set the letter is present. The 5 are listed below:</p>

<p>S = Sign Flag, Z = Zero, A = Auxilary Carry, C = Carry, P = Parity</p>

<p>To modify a register from the main loop, type 'R' followed by the letter of the register you wish to modify e.g. to modify the accumulator, type 'RA'. The value of the accumulator would then be printed with the cursor one space along, you may then enter a new value for the accumulator followed by 'return'. If you do not wish to modify the register you may exit by typing 'return' without entering any data. The monitor will signify an error condition and the register will not be changed. The same applies to the 16 bit registers SP or PC. To modify these registers type 'P' for program counter and 'S' for stack pointer. To display the flags from the main loop, type 'RF' and the flags set, if any, will be displayed. If you do not wish to change the flags, enter control C. To clear all the flags, type return or to set some flags type in their letters (as detailed above). The letters need not be in any order. An invalid character in the string will not be flagged as an error but will simply terminate the update i.e.: PZBCA will set the parity and zero flags only, resetting the others.</p>

<h3>C - Continue from a breakpoint</h3>

<p>This function requires no other data and loads up the registers in the 8080 with the pseudo-registers in memory (those displayed in the R function). The last register to be loaded is the program counter, causing an immediate jump to the address held in PC register.</p>

<h3>G - Goto Address</h3>

<p>This function will execute a machine code program at a specified address. When the letter is entered a start address will be requested; once the address has been entered by pressing 'return' the monitor checks for any errors and if none are found a carriage return followed by a line feed will be printed and the program will start to execute.</p>

<h3>A - ASCII String into Memory</h3>

<p>This function allows you to enter a string of characters into memory directly from the keyboard. The monitor will request a start address. When this has been entered correctly and the 'return' key is pressed the monitor will print a carriage return followed by a line feed and wait for you to enter some characters. As each character is entered it is displayed and entered into memory starting at the address specified. To delete characters use the 'DEL' key or control H. When the string has been entered an 'EOT' character (07H) must be entered to denote the end of the string. To obtain this character type control D - this will be entered into memory and the monitor will then print END:XXXX. Where XXXX is the address of the byte <u>after</u> the 'EOT' character, this should be the begin address of any subsequent strings. If 'EOT' is not required on the end of a string, terminate it with 'control C'. The 'control C' will not be entered and the end address is that of the byte immediately after the last character.</p>

<h3>D - Display String</h3>

<p>This function imitates a PSTRNG monitor utility (see later) and will print out any string from the address entered until it encounters an 'EOT' character such as those entered using the 'A' function. When this function is entered the start address of the string will be requested. When this has been entered a CR/LF sequence will be printed followed by the string. Unless it is known that a string exists at the entered address, it is best to use the 'N' function to find any strings. When this function is entered the start address of the string will be requested. When this is entered a CR/LF sequence will be printed followed by the string.</p>

<h3>U - Useful function (Port Operations)</h3>

<p>This function allows you to read and write to any port. When this function is entered the port number will be requested. This must be entered as a two digit hex number followed by 'return'; the data at that port will be displayed and you may either hit 'return', which will display the port data again (this is useful to see if the data at the port is changing) or alternatively, a two digit hex number may be entered - followed by 'return'. This data will then be written to the port and the data at the port will be read and displayed again. To exit from this function enter control C.</p>

<h3>H - HEX Dump</h3>

<p>This function produces a formatted hex-dump of memory between any two addresses. This allows for greater density than the 'L' function. The monitor will request a start address followed by an end address and will then produce a dump of memory (in hex) from the start address to the end address (inclusive). The dump is formatted so that the start of each line (with the exception of the first) will have the address XXX0; therefore all lines will contain 16 bytes (except the first and last). To exit from this function before it has finished type control C. To halt the printout temporarily enter control 'S' (X-OFF) to resume printout type control 'Q' (X-ON). These actions apply to all printout with the addition that when the printout has been halted with control 'S' a new line can be started by pressing the return key whereupon a CR/LF sequence will be printed. This is most useful when the output is diverted to a teletype or similar printer when a long line would otherwise be over-typed at the end stop. The printout can then be resumed with control 'Q'. When the dump has finished the oscillator will sound to inform you.</p>

<h3>L - List Memory</h3>

<p>This function will list short sections of memory by simply entering an address. When this function is entered a start address will be requested from the user. When this has been entered that address will be printed followed by the data in that location. This sequence will be repeated on subsequent lines for the next 15 locations and below that the prompt 'more?' will be printed. If you type 'Y' the next 15 locations will be listed, if you enter any other letter the function corresponding to that letter will be entered, if any other character is typed (e.g. the space bar) the error message will be printed and the monitor will enter the main loop.</p>

<h3>F - Find Bytes</h3>

<p>This function allows you to search memory between two addresses for any string of bytes. When this function is entered a start and end address are requested followed by the 'BYTE:' prompt. You may then enter a string of bytes separated by commas and the last byte terminated by pressing 'return'. The monitor will then start to search between the two addresses (inclusive) for that byte string and print out the locations (if any) where the string starts. When the search has finished the oscillator will sound to inform you.</p>

<h3>T - Trap</h3>

<p>Trap is the Triton Resident Assembly Language Package - it resides on an 8k EPROM card on the motherboard (see catalogue or documentation for details). This function will enter TRAP displaying the list of options available - no memory initialisation is performed by entry to TRAP and therefore program integrity is maintained.</p>

<h3>S - Shift Memory</h3>

<p>This function is more than a memory move instruction; it is an 'intelligent' move. When this function is entered a start and end address are requested from you. When you have entered the address of the block you wish to move (inclusive) the prompt 'TO:' will be printed - you then enter the address you wish to move the block to. After pressing 'return' the monitor will move the block and when finished beep the oscillator to tell you. 

<h3>I - Input Tape (in standard TRITON format) to memory</h3>

<p>This function will allow you to enter pre-recorded tapes into TRITON's memory starting at 1602. When 'I' is typed from the main loop the tape control relay will be switched off and a tape header requested. When this has been entered correctly (use the DEL key where appropriate) press 'return'. The tape relay will be switched on and the message 'FILES FOUND' will be printed. Note the cursor drops onto the next line. The tape will now be searched for a header corresponding to that typed in. As each header is found it is printed out and if the two do not correspond a CR/LF is printed and the monitor waits for the next header. If the monitor recognises the header the cursor stays on the same line whilst the program is loaded. When the tape has finished loading, the message 'END' is printed out, the oscillator will sound and the monitor will re-enter the main loop waiting for another command. If during loading an error occurs (due to a noise spike or bad tape etc.,) a CR/LF and a question mark will be printed - note that only one question mark will be printed no matter how many errors are detected. This may also mean that the monitor may not recognise the end of the tape when it comes. If this happens you must use the Reset switch since the monitor does not read the keyboard - this also applies to the 'O' function and whilst the monitor is looking for a header or loading the tape.</p>

<p>N.B: It is not advisable to try to load a tape when the output is directed to a printer since if the printer may not accept characters as fast as the tape is sending (30 characters per second) the header will not be printed correctly or recognised - therefore use the 'V' function first.</p>

<h3>O - Output a program to tape (in standard Triton format)</h3>

<p>This function will allow you to save machine code programs starting at 1602. When you type 'O' the tape relay will switch off and the tape header will be requested. When this has been entered start the tape recorder, then hit the return key -the monitor will switch on the recorder, wait for 5-6 seconds and then proceed to write the program in the TRITON standard format (see later). When the data has been written out the monitor will wait for 5-6 seconds and then switch off the relay, beep the oscillator for a moment and say 'END' before returning to the main monitor loop.</p>

<h3>W - Typewriter Mode</h3>

<p>Type 'W' and the monitor will print all characters entered until a control 'C' which aborts back to the monitor: The monitor will print onto the printer if it is selected.</p>

<h3>M - Motor Switch</h3>

<p>This function will toggle the tape-motor control relay - i.e. if it is off it will be turned on and vice versa. Once this has been done the monitor will print its function message and wait for another command.</p>

<h3>V - VDU Switch</h3>

<p>This function will direct the output to a printer as well as to the VDU. It therefore switches the printer output on and off. Even if you have no printer it can still be of use in slowing down the output by changing the value at locations 1402/3 the printout speed may be varied (this does not apply to V6.2P). It is initially set up to 110 Baud - for formula etc., see later. At reset the printer is off.</p>

<h3>X - Extended Basic</h3>

<p>This function enters BASIC without clearing memory or initialising vectors and therefore the J function should be used upon first entry to BASIC. To exit to the monitor from BASIC type control 'C'. N.B: To delete a character in BASIC you can now use the 'DEL' key instead of control H. In EDIT note the top right key (5FH) will give the delete character function.</p>

<h3>N - Neat Dump of Strings</h3>

<p>This function will produce a formatted text dump of memory. The monitor will request a start and end address and will produce a formatted dump between those 2 addresses (for details of format see H function). All printable upper case ascii characters (20 to 5FH) are printed as they are, otherwise a period (.) will be printed in its place - the characters are separated with spaces. When the dump has finished the tone will sound.</p>

<h3>Z - Zap A Prom.</h3>

<p>This function is to be used in conjunction with the EPROM programme card (available from Transam), it requests a start address and will then program the 2708 EPROM with that and the next 1023 locations in memory. Two errors are possible; 'PROGRAM ERROR' - indicating that the device has a bit set to 'Zero' that should go to 'one' - this is not possible although a logic one may be changed to a zero - the device will have to be erased. The other is a 'READ ERROR' this occurs if the data programmed into the device does not correspond to that in memory after the device has been programmed. If all goes well the monitor will say 'END' and sound the tone - the tone will also be sounded in the event of an error.</p>

<h3>K - Keyboard Unshift</h3>

<p>This function is mainly of use to those using Triton with a printer and/or the lower case graphics ROM as a letter writer or word processor. Typing 'K' will reverse the effect of the monitor's shift on the keyboard so it will act as a normal typewriter i.e. the lower case small - press shift to get upper case - this only affects the letters, numbers are as before. To get back to normal type Shift-K. At reset the shift is set to normal - upper case on unshift keys.</p>

<h2>HERE ENDETH THE LESSON..............</h2>

<p>That concludes the description of the functions - if you've ploughed through those - congratulations!</p>

<p>The following section contains notes on the use of the monitors various functions as examples. This is followed by notes on use, circuits, specifications, monitor routines and addresses.</p>

<h2>SETTING AN EXAMPLE</h2>

<p>In this section we shall use an example given in listing 1 to demonstrate the use of the monitor. This program inputs a character from the keyboard and maps it on the VDU.</p>

<p>A few brief words of explanation are in order for those of you unfamiliar with this type of listing - it is called an assembler listing and is split into 6 columns:-</p>

<pre>
ADDRESS DATA LABEL MNEMONIC OPERAND COMMENT 
   1      2    3      4        5       6
</pre>

<p>These listings are produced by the TRAP assembler. Columns 1 and 2 are those produced by the assembler, the first column listing the address, the data being from 3 bytes so one complete instruction is on one line - this makes the program much easier to read. The other columns are the original text, the 3rd column is optional and is used for referencing subroutines etc., the 4th and 5th columns are for the instruction and the 6th column contains any comments.</p>

<h3>Listing 1</h3>

<pre>
0000            ; PROGRAM TO DEMONSTRATE L7
0000            ;
0000                   ORG   1600H
0000            ;
1600            INCH   EQU   000BH
1600            RESPRP EQU   00ESH
1600            SCREEN EQU   1000H
1600            ;
1600 42 16             DW    ENDPRG  ;MARK END FOR TAPE
1602 CF         CLRSCN:RST   1       ;CLEAR SCREEN
1603 11 22 16          LXI   D,STRING;SET TO PRINT STRING
1606 CD E5 00          CALL  RESPRP  ;PRINT AND GET CHARACTER
1609 21 00 10          LXI   H,SCREEN;SET HL TO START OF VDU
160C 77         MAP:   MOV   M,A     ;PUT THE CHARACTER ON VDU
160D 7C                MOV   A,H     ;LOOK AT HIGH BYTE
160E FE 14             CPI   14H     ;END OF VDU?
1610 C2 0C 16          JNZ   MAP     ;NO- CARRY ON
1613 CD 0B 00          CALL  INCH    ;YES- WAIT FOR A KEY
1616 11 34 16          LXI   D,MESSG ;AND ASK IF MORE
1619 CD E5 00          CALL  RESPRP  ;GET REPLY
161C FE 59             CPI   'Y'     ;YES?
161E C0                RNZ           ;NO- BACK TO MONITOR
161F C3 02 16          JMP   CLRSCN  ;ELSE- DO AGAIN
1622            ;
1622            STRING:DB    'ENTER A CHARACTER',04H
1634            MESSG: DB    'AGAIN (Y/N) ?',04H
1642            ENDPRG:DS    0
1642                   END 
</pre>

<p>First of all clear memory to 0 so we can see what we are doing so type E 1600, FFFF as the end (for good measure) and 00 as the Byte, after a couple of seconds the function message will be printed after a beep - now list from 1600 to check this; type 'Y' to the 'more?' prompt, then type 'Q' to enter the program. Type the digits checking the addresses against those listed. Once entered use control 'C', then check using the L function to list again. If any bytes are entered wrongly change those with the 'P' function. Once we have entered the program we must enter the 2 strings -the first one starts at 1622, type A 1622 (RET) ENTER A CHARACTER (CONTROL-D). The end address should be 1634 so put the 2nd string in by typing A 1634 (RET) AGAIN (Y/N)?(CNTRL-D) - OK we should now be ready to run. Type G-1602. If the program has been entered correctly the screen should clear and the message 'ENTER A CHARACTER' will be displayed on the second line - hit a key and the VDU will be mapped continuously, hit INT2 and the screen should settle down and the registers displayed - the PC will be somewhere between 160C and 1610 and the HL register at 1000 which is the first position on the VDU - this is where the problem is - we haven't incremented it so the program will never end - we must insert an INX H instruction at 160D; but first we must make room for it - type S 160D 1642 160E so we are moving the block from 160D -1642 up one byte - having done this we can insert (using the P function) 23 at 160D and run once again. The message will be printed with a graphic character preceding it. This is because we moved the message by one byte, so we will have to change the address at 1604/5 - we can find where the strings have moved to by using the N function from 1610 to 164F. Put the correct addresses in 1604/5 and 1618/9 - having done this try again - the correct message is issued but we seem to have problems with the character - let's try a breakpoint - the best place to put one is at 160F. Using the P function put D7 at 160F and run again - we have now found the problem - the accumulator has been loaded with the H register so we have lost the original character. However, if we save the character in the B register and map the B register instead, this should solve the problem - we need to open out another gap at 1609, so using the S function move the program up and insert the byte 47 at 1609 and change the byte at 160D to 70 (MOV M,B).</p>

<p>Having done this change 1610 to FE - now all that remains is to change the addresses of the strings (again) so use the F function to search from 1600 to 1650 for 45,4E and 41,47 which are the first 2 bytes of the 1st and 2nd string respectively. Change 1604/5 and 1619/A again and run - it should now do what we said it would - and correspond to listing 2.</p>

<h3>Listing 2</h3>

<pre>
0000            ; PROGRAM TO DEMONSTRATE L7
0000            ;
0000                   ORG   1600H
0000            ;
1600            INCH   EQU   000BH
1600            RESPRP EQU   00ESH
1600            SCREEN EQU   1000H
1600            ;
1600 44 16             DW    ENDPRG  ;MARK END FOR TAPE
1602 CF         CLRSCN:RST   1       ;CLEAR SCREEN
1603 11 24 16          LXI   D,STRING;SET TO PRINT STRING
1606 CD E5 00          CALL  RESPRP  ;PRINT AND GET CHARACTER
1609 47                MOV   B,A     ;SAVE CHARACTER
160A 21 00 10          LXI   H,SCREEN;SET HL TO START OF VDU
160D 70         MAP:   MOV   M,B     ;PUT THE CHARACTER ON VDU
160E 23                INX   H       ;ON TO NEXT LOCATION
160F 7C                MOV   A,H     ;LOOK AT HIGH BYTE
1610 FE 14             CPI   14H     ;END OF VDU?
1612 C2 0D 16          JNZ   MAP     ;NO- CARRY ON
1615 CD 0B 00          CALL  INCH    ;YES- WAIT FOR A KEY
1618 11 36 16          LXI   D,MESSG ;AND ASK IF MORE
161B CD E5 00          CALL  RESPRP  ;GET REPLY
161E FE 59             CPI   'Y'     ;YES?
1620 C0                RNZ           ;NO- BACK TO MONITOR
1621 C3 02 16          JMP   CLRSCN  ;ELSE- DO AGAIN
1624            ;
1624 45 4E 54   STRING:DB    'ENTER A CHARACTER',04H
1627 45 52 20
162A 41 20 43
162D 48 41 52
1630 41 43 54
1633 45 52 04
1636 41 47 41   MESSG: DB    'AGAIN (Y/N) ?',04H
1639 49 4E 20
163C 28 59 2F
163F 4E 29 20
1642 3F 04
1644            ;
1644            ENDPRG:DS     0
1644                   END
INCH  000B   RESPRP 00E5    SCREEN 1000   ENDPRG 1644
CLRSCN1602   STRING 1624    MAP    160D   MESSG  1636
</pre>

<p>Now do a hex jump from 1600 to 1650 to find where the program ends and put this address in 1600/2 - we are now ready to save the program. Type 'O' and give the program any tape header start the recorder and press 'return' to send the data. To retrieve the program use the I function - whilst loading the tape deliberately stop and start the tape - a question mark should be shown on the next line - indicating a load error - only one question mark will appear. This concludes the example.</p>

<h2>NOTES ON USE:</h2>

<p>1. When a program is run a 'ret' instruction (C9) will return to the monitor (provided the stack is not reset).</p>

<p>2. When using the 'F' function a match will always be found at 1410 as this is where the match pattern is held.</p>

<p>3. Alter using TRAP it is best to do a reset as some of the interupt vectors may have been destroyed.</p>

<p>4. The monitor checks for a program in ROM 2 (IC22) before printing out the function message. If the first byte in the second rom is 31 (LXI SP) then the program in ROM 2 will be executed.</p>

<p>5. If an attempt is made to jump to non-existent memory (FF) this will be vectored back to the monitor (as with all the interrupts) so vastly diminishing the chances of destroying the program.</p>

<p>6. Tiny BASIC will not run with this monitor.</p>

<p>7. An explanation of the 'S' function - if the byte sequence 31,70,1A is held in memory and it is to be moved forward (UP) one byte to give 31,31,70,1A it must be moved from the top first otherwise we get 31,31,31,31 but if we want to move the other way we must start at the bottom.

<p>N.B.: TOP:FFFF &nbsp;&nbsp;BOTTOM:0000 &nbsp;&nbsp;UP:TOWARDS THE TOP &nbsp;&nbsp;DOWN:TOWARDS THE BOTTOM</p>

<p>8. The G function can be used for repeatedly executing a program by loading the stack pointer with 1470 and the PC with the address of the program - NOTE that in this case a 'return' to the monitor is not permissible - instead a jump to START must be used.</p>

<p>9. SETTING PRINTER MODE FROM PROGRAMS</p>

<pre>
POKE  $1401,$55  :REM PRINTER ON
POKE  $1401,$AA  :REM PRINTER OFF
3E55              MVI A,55H  ;PRINTER ON
32 01 1A          STA 1401H 
3EAA              MVI A,0AAH ;PRINTER OFF
3201 1A           STA 1401 H 
</pre>

<p>10. The Y function is vectored through ram at 1473 so to change the vector change the locations at 1474/5.</p>

<h2>KEYBOARD AUTO REPEAT AND OSCILLATOR</h2>

<img src="lvl7_fig1.png">

<p>R1 = 1k &#x00B1; 10%<br>
R2 = SEE TEXT<br>
RV1,2,3 = 10k PRESET<br>
C1 = 100&mu;F 16V ELECT<br>
C2 = 47&mu; 16V TANT<br>
C3 = 1&mu; 16V TANT<br>
C4 = 1&mu; POLYESTER<br>
D1 = 1N4148<br>
TRI = 2N3053<br>
G1-4 = 74LS132<br>
SPKR = 3-16 OHMS SPEAKER</p>

<h2>HOW IT WORKS</h2>

<p>AUTO REPEAT - with no strobe (input LOW) C1 is discharged and the input is now the output is high from G1 and C2 is fully charged. G3 o/p is high and the o/p G3 (acting as an inverter) is low. When a strobe arrives C1 starts to charge up (via RV1) but whilst it is charging (time determined by setting of RV1) the o/p of G1 is still high, since both inputs to G are high the output goes low - this is inverted by G3 sending a steady strobe to the input port. If now the strobe input goes low again, C1 discharges rapidly via D1 and the output goes low again. If, however, the input is maintained for long enough for C1 to charge up, both inputs from G1 are high and the output goes low - this sends the output (by G2+3) low again, this starts to discharge C2 - when C2 has discharged the input goes low sending the output high and giving a high output again - this starts to charge C2 again and so on until the strobe is removed. RV2 determines the rate of repeat.</p>

<h2>OSCILLATOR</h2>

<p>The principle of operation is similar to that of the repeat, but when the input (BIT7) is low the output of the gate is held high, but as soon as the output goes high the circuit starts to oscillate. Since C3 is small this occurs rapidly giving an audio frequency (adjustable by means of RV3). This is amplified by TRI to drive a small speaker. R2 should be chosen to give the appropriate tone - any value from 20R to 100R should be appropriate. Alternatively, a 30R resistor may be placed in series with a 100R wire wound potentiometer to act as a volume control. The switch included is optional but is desirable to allow the speaker to be switched direct from port 7 (for music programs etc). The oscillator should sound on an error and on the other functions detailed previously.</p>

<h2>CONSTRUCTION</h2>

<p>The circuit is reasonably simple and should pose no construction problems. Veroboard is one suitable method. The prototype was built on vero-strip board and mounted between the switches and transformer next to the speaker. The components should be mounted resistors first - the IC should be socketed - put C4 as close to IC1 as possible - this will stop weird effects when the oscillator sounds with auto repeat. Take care to insert the capacitors and diodes correctly. If the diode is reversed the repeat will start immediately.</p>

<img src="lvl7_fig2.png">

<p>The two circuits shown above are to interface the serial output from Triton to a 20ma or RS232 terminal. On certain TELETYPES* making the circuit below should suffice where the TTY supplies its own 20ma.</p>

<img src="lvl7_fig3.png">

<p>The reed relay is the same type as used on the tape I/O on Triton.</p>

<p>*Trade Mark of TELETYPE CORP.</p>

<h2>SERIAL I/O</h2>

<p>The level seven monitor provides a serial output to a printer. This can be turned on or off by using the V function, it can also be changed in programs as mentioned previously. The serial output appears as one bit on Bit 8 of Port 6 it is overridden in software and the speed of output can be easily changed by altering a value stored in RAM - see later.</p>

<p>The data is inverted - i.e. logic Zero is +5 and one 0V. The format is as follows:-</p>

<img src="lvl7_fig4.png">

<p>Each character starts with a start Bit followed by 8 data bits followed by a fake parity Bit (always 1) this is suitable for teletypes and most printers where parity checking is not needed. Two stop bits are sent at the end of each character with the exception of a carriage return where a continuous stop bit is sent for 3 character periods to allow the mechanism to return properly. This should be more than adequate for most machines. N.B. A special version of the monitor is available for high speed parallel printers such as the TRANSAM BD80. It should be noted that the character is output to the printer (if selected) before the VDU.</p>

<p>When the computer is reset, the serial o/p speed is set to 110 baud - Bit time = 9.09ms = 10 characters per second, to alter the speed the formula below should be used to calculate the value - converted to hex, and put into locations 1402/3.</p>

<img src="lvl7_fig5.png">

<p>The minimum value (0001) gives 6K baud at 7mHz or 15K baud, at 18mHz.</p>

<h2>TAPE-FORMAT</h2>

<p>The standard Triton format is used for input and output in the 7.1 monitor - this is detailed below.</p>

<p>Each Bit consists of a start Bit, 8 Data Bits, an odd parity Bit followed by 2 stop Bits. The actual record format is 5-6 seconds of continuous mark tone, 64 sync characters (0DH), program end address low, high, program, 5-6 seconds mark tone. The end address is stored in 1600,01, and this is automatically set up by tiny BASIC but must be preset by the user in machine code programs (see example) For BASIC L7.1 the tape routines are contained within the BASIC and these should be used for loading and storing L7.1 BASIC programs.</p>

<h2>MONITOR ROUTINES AND ADDRESSES</p>

<h3>MEMORY MAP</h3>

<p>This is a memory map of the L7.1 system.</p>

<img src="lvl7_fig6.png">

<p>The L7.1 monitor occupies locations 0000 to 03FF and 0C00 to 0FFF, the space from 0400 to 0BFF is left for user expansion (see previous section).</p>

<p>Useful addresses are listed below:</p>

<pre>
1401   DISSW      55 = PRINTER ON    AA = VDU ONLY
1403   SPEED      Baud rate
1410   BUFFER
1430   INT 3
1433   INT 4
1436   INT 5
1439   INT 6
143C   INT 7
1472   KEYSFT     80 = NORMAL        7F = TYPEWRITER SHIFT
1476   INVEC      INPUT VECTOR
1479   OUTVEC     OUTPUT VECTOR
</pre>

<h3>PORT ADDRESS</h3>

<table>
<tr><td>0</td><td>Keyboard - Input only - special routine needed.</td></tr>
<tr><td>1</td><td>Tape I/O UART status input</td></tr>
<tr><td>2</td><td>Tape I/O UART data strobe output</td></tr>
<tr><td>3</td><td>Led port output - On = Logic zero</td></tr>
<tr><td>4</td><td>Tape I/O UART receive data enable input</td></tr>
<tr><td>5</td><td>VDU output - Strobe routine needed</td></tr>
<tr><td>6</td><td>Serial O/P on Bit 8 - Bit 7 spare</td></tr>
<tr><td>7</td><td>Bit 8 = Relay - Bit 7 = Oscillator (speaker) (see circuit)</td></tr>
<tr><td>8 - 15</td><td>Decoded on board by 74LS154 (needs extra decoding)</td></tr>
<tr><td>16 - FF</td><td>Available for extensions</td></tr>
</table>

<h3>MONITOR UTILITIES</h3>

<table>
<tr><th>ADDRESS</th><th>NAME</th><th>COMMENTS</th></tr>
<tr><td>0000</td><td>RST0</td><td>Reset address. Sets up vectors - checks memory and prints initialisation message after clearing screen.</td></tr>
<tr><td>0008</td><td>RST1</td><td>Clears VDU and resets cursor returns after suitable delay with all registers intact.</td></tr>
<tr><td>000B</td><td>INCH</td><td>A call routine which waits for a character to be typed in from the input device and returns with the character in the accumulator all other registers intact.</td></tr>
<tr><td>0010</td><td>RST2</td><td>Interrupt 2 - Jumps to INIT routine, saves registers and prints them on VDU and printer (if selected) then enters main loop.</td></tr>
<tr><td>0013</td><td>OUTCH</td><td>Character output routine; outputs to the VDU (and printer if selected) the character in the accumulator, returns with all registers intact.</td></tr>
<tr><td>0018</td><td>RST3</td><td>INTERUPT 3; vectored to 1430 for user jump vector. (NOTE: on parallel printer versions this interrupt is not available to the user).</td></tr>
<tr><td>001B</td><td>INDATA</td><td>Will wait for characters to be entered from input device; echo on the VDU and put into memory pointed to by the DE register pair. On a carriage return the routine terminates; a space followed by an EOT character (04H) is stored in memory with the DE register pointing to the EOT character; the return is not stored.</td></tr>
<tr><td>0020</td><td>RST4</td><td>= Interrupt 4; vectored to 1433 for user operations.</td></tr>
<tr><td>0023</td><td>PDATA</td><td>Prints a string stored in memory pointed to by the DE register pair; returns on EOT with all registers intact with the exception of the DE pair; points to character <u>after</u> the EOT - allowing the routine to be called again for a string following the first.</td></tr>
<tr><td>0028</td><td>RST5</td><td>= Interrupt 5; vectored to 1436 for user operations.</td></tr>
<tr><td>002B</td><td>PSTRING</td><td>Similar to Pdata but a CR/LF sequence is output before the string is printed.</td></tr>
<tr><td>0030</td><td>RST6</td><td>= Interrupt 6; vectored to 1439 for user operations.</td></tr>
<tr><td>0033</td><td>PCRLF</td><td>Will output a CR/LF sequence to the output device(s); returns all registers intact.</td></tr>
<tr><td>0038</td><td>RST7</td><td>= Interrupt 7; vectored to 143C for user operations.</td></tr>
<tr><td>003B</td><td>ECHOCH</td><td>Will input a character from the input device and print it on the output device before returning it in the accumulator - all other registers intact.</td></tr>
</table>

<p>The above subroutines are fixed utilities and are guaranteed to remain at these addresses if another monitor is produced.</p>

<p>The routines listed below are not guaranteed to remain in these positions if subsequent versions of the monitor are released.</p>

<p>Routines marked with an asterisk (*) are in the same position as the V5.1 monitor.</p>

<table>
<tr><td>*URTOUT</td><td>003E</td><td>Will output the character in the accumulator to tape; returns registers intact.</td></tr>
<tr><td>*TAPOFF</td><td>004A</td><td>Will switch the tape motor relay off - returns with A=0 all other registers intact.</td></tr>
<tr><td>COMP</td><td>00BF</td><td>Will compare the DE to the HL register pair; returns C set if DE HL Z set if DE=HL and neither set if HL DE. A is lost.</td></tr>
<tr><td>*FIVSEC</td><td>00C5</td><td>Waits for 5-6 seconds before returning all registers intact.</td></tr>
<tr><td>RESPRP</td><td>00E5</td><td>Will print the CR/LF sequence followed by the string pointed to by the DE register pair and will then wait for a character to be entered, echo it and return with the character in A; the DE register pair will point to the location of the EOT character - all other registers intact.</td></tr> 
<tr><td>ERROR</td><td>015B</td><td>Will print a CR/LF followed by the message 'Error' and beep the oscillator before returning to the main loop.</td></tr>
<tr><td>ERR1</td><td>015E</td><td>As above but without the leading CR/LF.</td></tr>
<tr><td>PRBEEP</td><td>015A1</td><td>Will print the string pointed to by the DE register pair, beep the oscillator and return to the main loop.</td></tr>
<tr><td>BEEP</td><td>0154</td><td>Will sound the oscillator and return to the main loop.</td></tr>
<tr><td>START</td><td>0174</td><td>Re-enters the monitor main loop.</td></tr>
<tr><td>STRTAD</td><td>0208</td><td>Will print the prompt 'START:' and get a 4 digit address in the HL pair DE + A lost - aborts to monitor on error.</td></tr>
<tr><td>GETADR</td><td>020B</td><td>Will print the message pointed to by the DE pair and get an address as above.</td></tr>
<tr><td>G2BYT</td><td>020E</td><td>Will print a space and wait for an address to be entered as above.</td></tr>
<tr><td>STEND</td><td>022A</td><td>Will get a start and end address, end on top of stack - start below that. HL,DE,+A registers lost.</td></tr>
<tr><td>COMPI</td><td>0231</td><td>Similar to COMP but jumps to beep if DE-HL are equal.</td></tr>
<tr><td>PRADAT</td><td>023F</td><td>Prints the address pointed to by the HL pair and the data in that location on the next line. A is lost, others intact.</td></tr>
<tr><td>PRTLOC</td><td>0242</td><td>Prints the data pointed to by the HL pair - A lost.</td></tr>
<tr><td>ENDADR</td><td>0251</td><td>Prints the message 'END:' followed by the address in the HL pair. A and DE lost.</td></tr>
<tr><td>PRADI</td><td>0254</td><td>Prints the address in the HL pair.</td></tr>
<tr><td>RHEXSP</td><td>0259</td><td>Prints the data in the accumulator followed by a space. A lost.</td></tr>
<tr><td>PRTSPC</td><td>0256</td><td>Prints a space. A - lost.</td></tr>
<tr><td>INSPBF</td><td>027B</td><td>Prints a space then gets a string in the Buffer; returns on 'return' with a space followed by an EOT. DE points to EOT character. DE + A lost.</td></tr>
<tr><td>INBUFF</td><td>0270</td><td>Prints the character in A and gets a string in buffer as above. DE + A lost.</td></tr> 
<tr><td>PRTDAT</td><td>02AB</td><td>Prints the accumulator in hex - A lost.</td></tr>
<tr><td>TAPOUT</td><td>02C2</td><td>Turns the tape relay off, requests a header - gets header, turns relay on, waits 5 seconds, sends 64 sync characters followed by header and returns. A,B,D,E lost.</td></tr>
<tr><td>TAPIN</td><td>02E1</td><td>Turns the tape relay off, requests and gets a header - turns the tape relay on, prints the message 'FILES FOUND:' and searches the tape, printing all headers. Returns when a match is found. A,B,D,E lost.</td></tr>
<tr><td>URTER</td><td>0365</td><td>Gets a character from tape and checks for an error condition, prints out a CR/LF followed by '?' N.B. The C register must be loaded with '?' prior to calling this for the first time but not changed until tape loading is complete. B lost.</td></tr>
<tr><td>TAPRD</td><td>03E6</td><td>Gets a character from the tape and prints it on the VDU - repeats indefinitely.</td></tr>
<tr><td>*TAPON</td><td>03F6</td><td>Turns tape relay on. A returns 80H. All others intact.</td></tr>
<tr><td>GETACC</td><td>0C14</td><td>Expects to find 2 hex digits in buffer converts and puts in A. B + DE lost.</td></tr>
<tr><td>*UARTIN</td><td>0E62</td><td>Gets character from tape in A - other registers intact.</td></tr>
<tr><td>*TAPHDR</td><td></td><td>Turns relay off, requests and gets a header in buffer. DE + A lost.</td></tr>
<tr><td>ERRMSG</td><td>0ED6</td><td>Start address of string which prints 'ERROR'; call at 0ED7 to omit space. (Use via PDATA or PSTRNG).</td></tr>
<tr><td>STRMSG</td><td>0ECF</td><td>Start address of string which prints.'START:' Use as above.</td></tr>
<tr><td>ACKA</td><td>0FDS</td><td>Start address of string which prints 'HEADER:' Use as above.</td></tr>
<tr><td>ACKD</td><td>0E49</td><td>Start address of string which prints 'END', Use as above.</td></tr>
</table>

<h3>Notes for use with programs in TRITON manual.</h3>

<p>1. Using interrupt 3. Interrupt 3 is now vectored to 1430 so you should first insert the bytes C3,18,16 in locations 1430-2 before using the program.</p>

<p>2. Duo-Decimal program. Change the instruction at 1615 to RET by changing 1615 to C9.</p>

<p>3. Keyboard/Led Program version 2. Change the instruction at 160E in the alternative ending to RZ by changing the byte at 1610 to C8.</p>

<p>4. Alphabet twelve times using I/O - change instruction at 1615 as above.</p>

<p>5. Alphabet using memory mapping. Change the instruction at 1626 as in 3.</p>

<p>6. Modem echo test. Change the instruction at 1602 to call UARTOUT by changing the bytes at 1603/4 to 3E and 00 - change the instructions at 1606 to call UARTIN by changing the bytes at 1607-8 to 62 and 0EH.</p>

<p>7. Test tape playback program. Is now contained in the monitor at 03E6.</p>

<p>8. Test tape record program. Change the instructions at 1602, 160D, 1612 to call UARTOUT by changing the bytes following each of these addresses to 3E and 00.</p>

<h2>IMPLEMENTATION</h2>

<p>Level Seven is available direct from TRANSAM COMPONENTS LIMITED at 12 Chapel Street, London, N.W.1. They can be supplied in exchange for programmed EPROMS (see catalogue for details) TRAP is also available from TRANSAM.</p>

<h1>TRITON LEVEL SEVEN BASIC</h1>

<h2>INTRODUCTION</h2>

<p>The TRITON level seven BASIC is an extended BASIC with full mathematical and string functions plus features not available on any other 8K basics together with high speed execution.</p>

<h2>OVERVIEW</h2>

<p>The number range (using scientific notation) is 10 x 10<sup>38</sup> to 10 x 10<sup>-38</sup> (approx) with an accuracy of 6&frac12; digits (actually 24 binary bits), the last digit is rounded (if necessary). Numbers are displayed in conventional form unless the number exceeds the value 999999 or is smaller than .01 in which case the display will be in scientific format (sign, mantissa, exponent, sign, exponent).</p>

<p>Numbers are stored in binary resulting in faster execution, greater accuracy and more compact storage than other methods (such as B.C.D.).</p>

<p>Strings are also supported as an integral part of the BASIC and an extended range of string functions are available (including the very-powerful INSTR function). A full range of mathematical functions are also supported.</p>

<h2>GETTING IN</h2>

<p>To enter BASIC see the monitor section which should be read in full before continuing. Only if you have read this documentation fully and still have problems, should you contact TRANSAM.</p>

<p>You should now be in the command level of BASIC (the prompt '&gt;' has been printed and the computer awaits your command...)</p>

<h2>BACK TO BASICS</h2>

<p>Entering lines</p>

<p>A full line editing facility is available at all times when entering lines for BASIC whether in EDIT, INPUT or in the command level. This is achieved by using certain reserved characters for control purposes; these are detailed below:</p>

<table>
<tr><td>CNT-H (or DEL)</td><td>steps the cursor back one position in the line.</td></tr>
<tr><td>CNT-I</td><td>steps the cursor forward one position in the line.</td></tr>
<tr><td>CNT-K</td><td>steps the cursor forward to the end of the line.</td></tr>
<tr><td>CNT-L</td><td>steps the cursor back to the start of the line.</td></tr>
<tr><td>CNT-J</td><td>opens a space at the cursor position and moves all characters up to make room.</td></tr>
<tr><td>= (top key right)</td><td>will delete the character before the cursor and close the line up.</td></tr>
</table>

<p>Any other character is taken as a character to be placed in the line and steps the cursor on one position.</p>

<p>If any attempt is made to insert characters beyond the end of a line or backspace beyond the start of the line the commands are ignored.</p>

<p>To enter a line press the RETURN key, this will enter all characters to the left of the cursor, alternatively CNT-] can be used to enter the whole line regardless of the cursor position.</p>

<h2>ESCAPE CODES</h2>

<p>The ESC key is used when entering lines for entering a whole word with two keys; the ESC key is followed by another key which will signify the word to be entered. Most keys will produce words; these are listed below. CNT-C will cause a return to the monitor as usual. Note that control characters do not perform their usual editing functions if preceded by ESC.</p>

<pre>
CNT A    PRINT        CNT B    AUTO           CNT D       CLEAR
CNT E    CLS          CNT F    CALL           CNT G       DIM
CNT H    DATA         CNT I    DUMP           CNT J       DEF
CNT K    EDIT         CNT L    ERASE          CNT M (RET) END
CNT N    FOR          CNT O    GOTO           CNT P       GOSUB
CNT Q    GET          CNT R    HELP           CNT S       INPUT
CNT T    IF           CNT U    LPRINT         CNT V       LIST
CNT W    LINE         CNT X    LOAD           CNT Y       LET
CNT Z    NEXT         CNT [    OFF            CNT ES      OUT
CNT ]    ON           CNT ↑    POKE           CNT =       RUN
space    RETURN       !        RESTORE        "           REM
#        READ         $        RANDOMIZE      %           RESUME
&        REPLACE      '        RENUM          (           STOP
)        SWAP         *        SAVE           +           SCR
,        TRACE        -        VDU            .           WIDTH
/        NOT          0        THEN           1           ELSE
2        TO           3        STEP           4           USING
5        MOD          6        AND            7           OR
8        XOR          9        +              :           -
;        *            <        /              =  
>        <            ?        =              =           @
A        FN           B        PI             C           TAB(
D        SPC(         E        BAS            F           ASC
G        ATN          H        COS            I           CHR
J        EXP          K        FRE            L           HEX
M        INP          N        INT            O           LEN
P        LOG          Q        PEEK           R           RND
S        SGN          T        SIN            U           SQR
V        STR          W        TAN            X           VAL
Y        LEFT         Z        RIGHT          [           MID
/        INSTR        ]        STRING
</pre>

<h2>ABBREVIATIONS</h2>

<p>In addition to the above escape codes, many of the words can be abbreviated by using the ] key. The abbreviations are listed below (all words are listed in full during LIST).</p>

<pre>
]       PRINT      A]     AUTO        C]     CONT
CL]     CLEAR      CA]    CALL        D]     DIM
DA]     DATA       DU]    DUMP        E]     EDIT
ER]     ERASE      F]     FOR         G]     GOTO
GOS]    GOSUB      H]     HELP        I]     INPUT
L]      LPRINT     LI]    LIST        LO]    LOAD
M]      MID        N]     NEXT        O]     OFF
P]      POKE       PE]    PEEK        R]     RUN
RE]     RETURN     RES]   RESTORE     RA]    RANDOMIZE
S]      STOP       SW]    SWAP        SA]    SAVE
T]      TRACE      TH]    THEN        V]     VDU
W]      WIDTH      X]     XOR
</pre>

<h2>FORMATTING</h2>

<p>BASIC level seven has a unique space-saving feature which permits faster execution and more compact storage together with a fixed format listing resulting in greater readability and freedom of formatting when entering lines. Each reserved word (those listed as words under ESC codes) is stored as one byte and spaces are not stored (except in quoted strings or in REM statements) and are automatically converted to full words on LIST and spaces are added according to certain rules - giving a listing which will correspond exactly to another, no matter whether the original was typed with or without spaces.</p>

<p>Spaces are optional and may be placed anywhere in line with certain exceptions - these are that a reserved word may not contain spaces and if a combination of letters could be wrongly interpreted as another word: for example 6 IF F OR T THEN 43 should not be entered as: 6 IFFORTTHEN as this will be interpreted as IF FOR T THEN. This should therefore be entered as 6IFF ORTTHEN43 which will be interpreted correctly. Note that if a keyword is entered with an embedded space it will not be interpreted and can cause weird syntax errors. Where the listing appears correct but yields a SYNTAX ERROR IN LINE 12 re-enter the line by using EDIT and exit from the line with CNT-]. If this does not work the error must exist in some other place.</p>

<h2>BASIC BASIC<h2>

<h3>VARIABLES</h3>

<p>BASIC uses variables as a means for conveying values in programs. A variable is a symbolic name given to a value; the value that the name represents may be changed at any time in the program and is stored in decimal at all times so resulting in greater flexibility over systems which have limited type variables. Variables must start with a letter and can contain any number of letters or numbers thereafter. Note however, that only the first two characters are unique to a variable and therefore CAT and CANDY are the same variable (CA). Variables may not contain reserved words; some examples of valid and invalid variables are given below:

<table>
<tr><td><u>Acceptable Variables</u>&nbsp;&nbsp;&nbsp;</td><td><u>Unacceptable Variables</u></td></tr>
<tr><td><p>A</br>C2</br>XX</br>COPY</br>UXZC</p></td><td><p>31 (begins with a digit)</br>28 (numeric constant)</br>ONE (contains keyword ON)</p></td></tr>
</table>

<p>Undeclared variables which are accessed are given the value 0.</p>

<h3>STRING VARIABLES</h3>

<p>String variables are formed in the same way as numeric variables and are followed by a dollar ($). The same rules apply as for numerics; the variable A1 and 1$ are distinct variables and may be used together, if a string variable is undeclared, it takes the value of a null string ( "" ). This assures that later changes or additions will not yield errors or unpredictable results.</p>

<h3>ENTER</h3>

<p>To enter a line in basic is a simple operation. Lines may be of two forms; the first is an immediate command and will be executed immediately the RETURN key is pressed to enter the line; this is also referred to as the DIRECT ENTRY mode. Try entering the immediate command PRINT "the dragon" followed by the RETURN key - Triton should then do as you say and print 'the dragon' on the next line. Below this it will print READY to tell you it has finished executing the program and awaits your next command. Certain commands may not be used as direct statements (DEF, INPUT and LINE input) and others are illogical (DIM, DATA etc..) but may be used. Any command may be put in a program (including RUN, EDIT and SCR).</p>

<p>The second form is as follows. To enter a line as part of a program type a line number before the commands; this will cause the line to be stored in memory as part of the program and will not be executed immediately. TRY entering the following line:</p>

<pre>
1 GOTO 1
</pre>

<p>the computer will merely re-prompt you with &gt; and wait for your next command. It has entered the line into memory and we can check this by executing a list command; type LIST and the line entered will be listed. To run the program enter the command RUN; the computer will then seem to do nothing. Don't worry; if you look at the program you will see why; we have put the computer in an infinite loop - it is 'chasing its' tail' so to speak. To stop the program we must take some action. Press the top right hand key on the keyboard. This is called the break key - the message BREAK IN LINE 1 will be printed to tell you that the program has been interrupted in line 1; we can continue the program where we left off by using the CONT command. This will again lock the computer in a loop so we must use the break key to stop it (note that to break from an INPUT statement use CNT-D). To get rid of the program type SCR; this will delete all lines from the program, you can verify by using the LIST command.</p>

<h3>FEATURES</h3>

<p>Level seven BASIC has many unique and useful features not found on other 8k basics. Some of the more unusual features are detailed hereunder.</p>

<h3>HEX CONSTANTS</h3>

<p>Level seven supports hex constants in a program and these are denoted by a preceding dollar sign. These can be used as normal constants (H=$c9) as data ( 10 DATA $CD,$00,$13 ) or as an entry for an INPUT command.</p>

<h3>HEX STRINGS</h3>

<p>Hex strings may be created for any integer from 0 to 65535. The HEX function will produce a string with the hex value of the argument.</p>

<p>These two features make base-conversion unnecessary in the monitor and indeed hex constants in the program make is much easier to read. Both features can of course be used in the immediate mode to give conversions.</p>

<h3>DATA FILES</h3>

<p>Data files are simply implemented in level seven by the unique feature of being able to save and load string and numeric arrays in the program. A very powerfull SAVE and LOAD structure permits great flexibility in data storage without restricting its power.</p>

<h2>COMMANDS</h2>

<p>All commands may be used in a program (Including SCR) so, for instance a program may list part of itself and then execute that part. Certain commands do, however, not resume the program and exit to the command level. These commands are: SCR, STOP, END, EDIT and AUTO.</p>

<p>NOTE: The list of words given previously are not all implemented in release 1 of the BASIC; these commands will give a SYNTAX ERROR if used and no plans are made to implement any of these extra words. The words in question are: HELP, RESUME, REPLACE, RENUM, USING and MOD.</p>

<h3>ARITHMETIC OPERATIONS</h3>

<p>Where a formula for a calculation contains more that one operation certain rules are used in deciding the order of operators execution. In any formula BASIC will perform operations in the following order:</p>

<ol>
<li>Parentheses are the highest priority and any expression in parentheses will be executed before the rest of the line. This also applies to nested parentheses; the innermost expression will be evaluated first.</li>
<li>Exponentiation</li>
<li>Unary minus</li>
<li>Multiplication or division (of equal priority)</li>
<li>Addition or Subtraction</li>
<li>Logical operators in the order NOT, AND, OR or XOR (OR and XOR same priority)</li>
</ol>

<p>If the rules do not clearly designate the order of evaluation, the expression will be evaluated from left to right. The expression X^Y^Z</p>

<ol>
<li>X^Y = step 1</li>
<li>(result step 1)^Z = step 2</li>
</ol>

<h3>PARAMETERS</h3>

<p>The commands LIST and SCR may be justified with parameters to restrict the range of their operation. If no parameters are specified the operation is performed on the whole of the program (i.e. the whole program is listed or deleted). If one operand is specified it is performed on that line, or the next line following it (unless it is beyond the end of the program), so for instance if a program contains lines 10, 20 and 40 and the command SCR 30 is issued line 40 will be deleted (the same applies to list). If two operands are specified (separated by a dash (-)) the operation is performed for the first line (or the next one) through to the last line (or the one before it). A summary is given below:</p>

<ol>
<li>LIST will list all lines</li>
<li>LIST 10 will list line 10 (or the next line)</li>
<li>LIST 10-40 will list from line 10 (or next) to 40 (or preceding)</li>
<li>LIST -10 will list from the start to line 10</li>
<li>LIST 10- will list from line 10 to the end.</li>
</ol>

<h3>AUTO</h3>

<p>Level seven has a useful and easy to use AUTO command for supplying line numbers when entering programs. Auto entered on its own will cause 10 to be printed out, and each time return is pressed it will step 10. To change the start to 100 enter AUTO 100. To change the step to 5 enter AUTO 10,5. This will start at line ten and increment in steps of five.</p>

<p>If the line number exceeds 65529, Basic will complain with an OVERFLOW ERROR.</p>

<p>If the line number being printed already exists in memory an asterisk is printed before the line to warn the user. He may take one of the following steps if this happens:</p>

<ol> 
<li>Ignore it and enter the line. This will replace the line already in store</li>
<li>Leave the AUTO mode by entering CNT-D.</li>
<li>Delete the line by typing RETURN.</li>
<li>Leave the line in memory by issuing a CNT-L followed by a RETURN.</li>
</ol>

<p>To quit from AUTO enter CNT-D.</p>

<h3>PRINT</h3>

<p>This is BASIC's main output command and is used for printing values strings etc..</p>

<h3>LPRINT</h3>

<p>LPRINT follows the same rules as PRINT with the addition that the line will be sent to the printer as well as to the VDU. The printout always returns to the vdu only after an LPRINT. Wherever PRINT is used LPRINT may be substituted.</p>

<p>PRINT used alone (or followed by a colon) will result in a CR/LF being printed (Carriage Return &amp; Line Feed). PRINT may be abbreviated to ].</p>

<p>Characters enclosed in quotes are printed as entered. As in all quoted strings if the last character on the line is a quote (") it may be omitted to save space - eg: PRINT "HELLO THERE" and PRINT "HELLO THERE will both produce the correct message but the second example uses one less byte.</p>

<p>Two separators are used to separate items in a PRINT statement. These are a comma (,) and a semi-colon (;). The comma will move the cursor to the next tab position (every 8 characters). A semi-colon will print a single space unless it is the last character in the print statement in which case it will not move the cursor. If no separator is used no spaces will be output, so for instance an answer to a sum can be put next to a quoted string as in PRINT "THE ANSWER = "A+B which would produce something like THE ANSWER = 32 which is much more readable and uses less storage than the usual semi-colon separator.</p>

<p>Note for use with other BASIC's: Some other BASIC's use a semi-colon to separate items without printing a space. In this case the semi-colon may be omitted so the string "HELLO ";A ;" HOW ARE YOU" may be entered as either "HELLO "A " HOW ARE YOU" or "HELLO":A :"HOW ARE YOU" both of which will produce the same printout and both of which save 2 bytes over the original.</p>

<p>If it is wished to print 2 (or more) strings combined without a space either PRINT A B or PRINT A +B may be used; the first one is preferable since it does not use extra space (if there is not enough room a NO STRING SPACE ERROR will be printed, but this cannot happen with the first example. Also the second example uses one extra byte).</p>

<p>Two functions are available in PRINT which produce formatting, the first, TAB will move the cursor to the column specified in the argument (providing it has not passed it already) and SPC will print the specified (up to 255) number of spaces.</p>

<p>Numbers are printed as detailed before with leading and trailing zeroes suppressed.</p>

<p>Scientific notation consists of the sign, mantissa, sign, exponent. EG 12345000 would be printed as 1.2345E+7.</p>

<h3>INPUT</h3>

<p>The command used to get replys from the user, used for both string and numeric data.</p>

<p>Multiple inputs are allowed and the elements (variables) to be entered are separated by commas.</p>

<p>e.g. INPUT A,B$,H</p>

<p>This input will cause the default prompt (?) to be printed. The user could then enter the data separated by commas, as on the input statement (EG 12,FRED,33.763) and would assign 12 to A 'FRED' to B$ and 33.763 to H. If the user only entered one or two items (EG 12,HARRY), BASIC would re-prompt for the remaining items with a question mark. If too many items were entered the excess items are ignored without producing any form of error message. If the user wishes to supply his own prompt then this is enclosed in quotes before a semi-colon and the variable. This would then be printed WITHOUT the question mark and without any extra spacing.</p>

<p>E.G. INPUT "WHAT IS YOUR NAME ? ";NAME$</p>

<p>If a RETURN is typed without any other characters being entered for a string, a null string ("") is returned, if for a numeric value, the value 0 is returned. If a numeric value is required and string data is entered BASIC will re-prompt with the original prompt.</p> 

<h3>LINE INPUT</h3>

<p>A special version of INPUT for strings may be supplied with a prompt in quotes and ONE STRING variable. It then prompts the user with the prompt supplied and will save all characters up to the RETURN in the string variable named. This includes leading spaces, quotes ("), colons (:) and commas (,) all of which are not used on a normal string INPUT. As before a single RETURN will produce a null string.</p>

<h3>GET</h3>

<p>This is a special, real time feature for getting information without waiting for a RETURN. This feature opens up many possibilities in the fields of interactive games and simulations. The GET command produces no prompt and does not echo any characters typed. When used it returns immediately, whether a key has been pressed or not. If a numeric variable is specified the GET will return 1 to 9 if the keys 1 to 9 are pressed; otherwise it will return 0 (as with INPUT). If a string variable is specified any key pressed will be returned as a single character string. If no key is pressed a null string ("") is returned. Only one argument is allowed.</p>

<p>EG 100 GET A$ :IF A$ ="Y" THEN PRINT "YES" ELSE GOTO 100</p>

<p>will wait for Y to be pressed and print YES before continuing.</p>

<h3>RUN</h3>

<p>Used alone will clear all variables and arrays and execute the program from the lowest numbered statement. If a line number is specified then execution will commence at the line specified. (if the line specified does not exist the error message MISSING LINE ERROR would be displayed).</p> 

<p>The use of RUN performs an implicit CLEAR. RUN may be used in a program.</p>

<h3>CLEAR</h3>

<p>Clear has two distinct forms, both of which clear all variables, strings and arrays. Used alone it will free all free memory for use. When used with a number it will reserve that number of bytes for exclusive use of strings. This defaults at power-on to 50 and can be altered by the user to any figure (so long as there is sufficient memory). If an attempt to use too much space is made, NO SPACE ERROR is printed. The number of free bytes for strings can be determined by using the FRE(A$)) function. If there is not sufficient space for strings (indicating a larger CLEAR number is required) the error message NO STRING SPACE will be printed.</p>

<h3>SCR</h3>

<p>Unique to LEVEL SEVEN BASIC this feature allows for deletion of blocks of lines as well as the whole program. (For parameters see list parameter section). SCR will clear the whole program as normal. Note that line numbers quoted as parameters are INCLUSIVE.</p>

<h3>LIST</h3>

<p>Allows blocks of lines or the whole program to be listed in the standard BASIC format (for parameters see previous section).</p>

<h3>READ</h3>

<p>Used in conjunction with the DATA statement allows data to be placed within a program and obtained in the same manner as an input statement. If there is insufficient data in the program to satisfy a read statement a MISSING DATA error is generated, if a mismatch occurs between the READ and DATA statements (ie the variable is numeric and the data is string) the message SYNTAX ERROR IN 1000 (or whatever line contains the data) is printed.</p>

<h3>RESTORE</h3>

<p>Allows the user to re-use data by resetting the point at which data is to be read in the program. Used alone it will reset the position to the first DATA statement (performed automatically by RUN). If it is followed by a line number, it will go to that line (providing it exists).</p>

<h3>DATA</h3>

<p>The complement to READ statement above, may contain mixed data in the same line. The string data must be enclosed in quotes if the string contains any spaces or commas or colons; otherwise they are optional. (Note that the trailing quote may be omitted if it is the last character on the line).</p>

<p>EG 233 DATA 12,hello,HELP," THIS IS A ,,STRING</p>

<h3>DIM</h3>

<p>Used to reserve space for matrices, which may contain up to 255 dimensions and each dimension up to 65535 elements (memory allowing). The elements must all be the same type. Arrays (matrices) are named in the same way as variables (see previous section). Several different arrays may be dimensioned at once by separating the separate arrays with commas. A dimension is not necessary if the individual dimensions are less than 10. If an element is accessed from an array before it is dimensioned it will be dimensioned to 10 elements per dimension (actually 11 because of the zero subscript). It is always best to dimension the array first for readability and to save space. Also note the use of the zero element which is present in all arrays. If an attempt is made to read an element not in an array (too big, not enough dimensions or too many dimensions) the error message BAD SUBSCRIPT ERROR will be printed. If an attempt is made to dimension an array twice or to dimension an array after using an element (in which case it will automatically dimension to 11 or 11x11) the error message REDIMENSION ERROR will be printed.</p>

<h3>GOTO</h3>

<p>Used to transfer execution to another line. The expression following the word GOTO must refer to a valid line otherwise an error will occur. Any numeric expression may be used.</p>

<p>EG GOTO 100 &nbsp;&nbsp;&nbsp;&nbsp;GOTO 1000+A*20</p>

<p>The GOTO command can also be used to run a program without resetting the variables and arrays.</p>

<h3>GOSUB</h3>

<p>Used to execute a subroutine. The argument form is as shown above for GOTO.</p>

<h3>RETURN</h3>

<p>Used to end a subroutine; returns to the point after the corresponding GOSUB.</p>

<h3>FOR</h3>

<p>Used with NEXT for loop operations. Defaults to a step of 1. Will always execute at least once.</p>

<p>EG FOR A=1 TO 10</p>

<h3>STEP</h3>

<p>Used to alter the step after execution of a for next loop, if ommitted defaults to 1</p>

<p>EG FOR O=1 TO -1 STEP -1</p>

<h3>NEXT</h3>

<p>Used to terminate a FOR loop. May be followed by the variable of the FOR statement, defaults to the innermost loop (the last FOR statement). If no preceding FOR is present the error MISSING FOR ERROR will be printed.</p>

<h3>NESTING</h3>

<p>Is limited only by memory size and is typically in the region of 300-400 levels.</p>

<p>EG NEXT &nbsp;&nbsp;&nbsp;&nbsp;NEXT COUNT &nbsp;&nbsp;&nbsp;&nbsp;NEXT I,J (special case for multiple for loops).</p>

<h3>IF</h3>

<p>This is the conditional test to determine the course of action to be taken by the program.</p>

<p>The THEN is optional as a qualifier but may be needed in certain circumstances.</p>

<p>EG IF A=+1 THEN 30 &nbsp;&nbsp;&nbsp;&nbsp;IF A&gt;=B PRINT "THEY ARE EQUAL" &nbsp;&nbsp;&nbsp;&nbsp;IF A&lt;=S4 THEN A=4 :GOTO C &nbsp;&nbsp;&nbsp;&nbsp;IF A&lt;&gt;L THEN PRINT "YOU LOSE</p>

<p>ELSE may also be used and will be executed if the comparison is false.</p>

<p>EG IF A&gt;N THEN PRINT "YES" ELSE PRINT "NO &nbsp;&nbsp;&nbsp;&nbsp;IF A&lt;G-5/2 THEN 40 ELSE 80</p>

<p>Note that if the qualifier (either THEN or ELSE) is used as a conditional GOTO, the number must be a constant. To use an expression, GOTO should be used.</p>

<p>EG IF A=GG GOTO A*10 ELSE GOTO GG*100</p>

<p>Else may be nested.</p>

<p>EG IF A=2 GOTO 34 ELSE IF A=12 GOTO 47 ELSE PRINT "ERROR":END</p>

<p>If ELSE is not present execution will continue on the next line if the comparison is false. If ELSE is used it must appear on the same line as the IF. Execution will continue on the next line when an ELSE is encountered.</p>

<h3>CLS</h3>

<p>Clears the vdu, incorporates a delay. No arguments needed.</p>

<h3>VDU</h3>

<p>Used for sending ASCII codes to, and memory mapping the VDU. Must contain 2 arguments, separated by commas, the first argument must lie in the range 0 to 1024 and determines the position of the character to be mapped. If 0 is used the character is output in the normal way through the port. This is used for sending control characters which could not be put in a PRINT statement.</p>

<p>EG To send a line feed only to the terminal, use VDU 0,$0D.</p>

<p>The second argument is the character to be sent, or mapped. It must lie in the range 0 to 255. Characters greater than 127 are the same as 0 to 127. Eg 128 is the same as 0.</p>

<p>EG FOR POS=1 TO $400:VDU POS,$20:NEXT :REM SLOW CLEAR OF VDU</p>

<h3>POKE</h3>

<p>Used for changing memory; consists of two arguments separated by a comma. The first argument is the address and must be between 0 and 65535 ($FFFF). The second argument is the value to be put at that address and must lie in the range 0 to 255 ($FF).</p>

<h3>OUT</h3>

<p>Used for outputting values to the 8080 ports; consists of two arguments separated by commas, both of which must be in the range 0 to 255 ($FF). The first argument gives the port number, the second the value to be sent to the port.</p>

<h3>CALL</h3>

<p>Used for interfacing user written machine code routines to the main BASIC program. Consists of 3 arguments separated by commas. The first argument must lie in the range 0 to 65535 ($FFFF) and is the address to be called. The second argument must lie in the same range, and is passed to the user program in the DE register pair. The third parameter must be a variable and is used to store the value of the DE pair on return. All registers may be destroyed (except the SP) and a return to BASIC is accomplished with a RET instruction at the end of the user program ($C9).</p>

<p>EG CALL $3000,A,A &nbsp;&nbsp;&nbsp;&nbsp;CALL C,V,I</p>

<h3>END</h3>

<p>Used to stop execution of the program and may be put anywhere in the program.</p>

<h3>CONT</h3>

<p>Used to continue execution of a program after it has been halted by a stop command, by typing CNT-D on an INPUT statement or by hitting BREAK during execution. May only be used if the program has not been changed. If the program has been changed, or an error has occurred, the error message CONT ERROR will be printed.</p>

<h3>EDIT</h3>

<p>Used to recall a line into the input buffer for editing in the normal way (see line editing). EDIT is followed by the number of the line to be edited. The line is then printed out as it would be in the LIST command. If the line is too long to fit in the buffer an OVERFLOW ERROR is given and the line remains intact and unchanged. The line is printed out and the cursor moved to the start of the line. Editing may be carried out in the normal way; the line number can be edited to facilitate copying lines without re-typing the whole line, or small changes can be made.</p>

<h3>LET</h3>

<p>Used to assign a value to a variable, (optional).</p>

<h3>ON</h3>

<p>Another form of conditional GOTO, may be used with GOTO or GOSUB. Takes the form .. ON var GOTO (GOSUB) num,num,num... var is any variable and num is a line number. Var may be an expression. The expression is evaluated and a GOTO (or GOSUB) executed to the N'th line number.</p>

<p>EG The following code can be replaced by an ON command.</p>

<pre>
100 IF A=1 THEN 1000
110 IF A=2 THEN 1100
120 IF A=4 THEN 2006
130 IF A=5 THEN 2088
140 IF A=6 THEN 3000
150 PRINT "ERROR ------"
</pre>

<p>Can be replaced by:</p>

<pre>
100 ON A GOTO 1000,1100,150,2006,2088,3000
150 PRINT "ERROR ------"
</pre>

<p>Note that line 150 was inserted if A was 3. If the number (A) is less than 1 or greater than the number of lines listed then execution continues after the last number (the next statement). With GOSUB the RETURN instruction will cause a return to the next statement after the ON GOSUB.</p>

<h3>DEF</h3>

<p>Def is used to define the user function. The function has one local parameter (one that cannot be used by the rest of the program), and the statement takes the form</p>

<pre>
DEF FNR(X)=INT(X*RND(1))
</pre>

<p>FN is the common name for all user functions and is followed by a name (names for functions are made in the same way as variables) in this case R. X is the local parameter and is distinct from the variable X which may co-exist. Wherever X is used on the right hand side of the equals sign the parameter is substituted. This means that the variable X cannot be used and this should be borne in mind when writing programs. Any other variables may be used on the right hand side. The parameter need not be used at all (a dummy parameter). The user defined function is used as in any expression like:</p>

<pre>
A=FNR(4)
</pre>

<p>which result in A taking a random value from 0 to 3. The function must be declared before it is used. A DEF statement may not be used as an immediate command.</p>

<h3>REM</h3>

<p>Used for putting comments into programs, the rest of the line after a REM is ignored and stored as it is typed.</p>

<h2>BASIC FILES</h2>

<p>File handling in Level Seven BASIC is made easy by the use of SAVE and LOAD for arrays (see next section). These can be string or numeric and usually the average program can make do with one of each.</p>

<p>Given below is a short example of how to go about implementing data files:</p>

<pre>
10 CLS:PRINT "DEMO PROGRAM
20 INPUT "1=LOAD 2=SAVE 3=EDIT ";T:ON T GOTO 30,100,200
30 INPUT "LOAD TAPE AND PRESS RETURN";A$:LOAD("FIL1")@DS,D
40 GOTO 20
100 INPUT "LOAD TAPE AND PRESS RETURN";A$:SAVE("FIL1")@DS,D
110 GOTO 20
200 INPUT "ITEM NO. ";T
210 PRINT "ITEM";T;D$(T)TAB(20)"QTY="D(T);:INPUT"ENTER NEW QTY";D(T)
220 INPUT "ANOTHER ?";A$:IF LEFT$(A$,1)="Y"THEN200 ELSE 20
</pre>

<p>This would be the basis of a very simple stock-keeping program but it should give you the idea of how to write a practical program (you would need to add DIMs to the program as well as some means of entering the item names to the program above.)</p>

<h3>SAVE</h3>

<p>Used for saving user programs or data, it has many unique features. The tape format used is special and not compatible with other formats. This means that programs written for levels 4, 5 or 6 will have to be typed into level seven; machine code programs may still be loaded from the monitor in the normal way. O may not be used for saving a BASIC program.</p>

<p>SAVE may have a specified name or, if none is specified, the default header '$$$' is sent. The header is enclosed in round brackets and may be any string expression. If no extra parameters are specified the BASIC program in memory is saved.</p>

<p>EG SAVE will save the program with the header '$$$'<br>
SAVE ("PROG *1") will save the program with the header 'PROG*1'<br>
SAVE (NAME$ ) will save the program with the header NAME$.</p>

<p>If an attempt is made to specify a number a TYPE MISMATCH ERROR will be printed.</p>

<p>To save a block of memory (such as a maching code program) the addresses are placed after SAVE (the header if used)</p>

<p>EG SAVE 1600, 1800 will save the block from 1600 to 1800 (hex).</br>
SAVE ("TEST")A,B will save the block from A to B with the header 'TEST'</p>

<p>To save an array it must have been previously dimensioned and is saved in full. The array name is preceded by an '@' to specify an array.</p>

<p>EG SAVE @A will save the numeric array A with the header '$$$'</br>
SAVE (DAT$)@ST$ will save the string array ST$ with the header DAT$</br>
SAVE ("ARY"+A$)@A will save the numeric array with the header 'ARY'+A$</p>

<p>SAVE may be placed in a program or used as an immediate command. When it is executed it switches the motor on, waits 6 seconds and then sends the data. If the list of items to save is a comma, the SAVE will be executed on the next item, followed by with only 1 6 second gap.</p>

<p>EG SAVE @$,("AR")@D$ will have a six second gap, the header $$$ followed by numeric array $ followed by a 6 second gap followed by the header 'AR' and string array D.</p>

<p>SAVE, will save the program with the header '$$$' twice.</p>

<p>The tape relay is switched off five seconds after the last item in the list has been sent.</p>

<h3>LOAD</h3>

<p>Used to recover files saved by use of the save command. Note that it will not load files from TRAP, L6 or tiny BASIC L5 or L4.</p>

<p>The format for the load command is the same as for the save command with the exception that programs do not have an address following them, even if you are loading a machine code program. To load a program, only the header must match and the program will be loaded to the original address from which it was saved.</p>

<p>If the file loaded was a BASIC program it will run automatically from the lowest line, if not, execution will continue at the next statement.</p>

<p>LOAD used alone will search the tape for a program (BASIC or Machine code) and load the first program it encounters into memory. If a header is specified (as in SAVE) this header will be searched for, the message:</p>

<pre>
FILES FOUND:
</pre>

<p>will be printed and the computer will search the tape for a program. As each program is found the title will be printed out. If the computer is loading the file, the cursor will stay on the same line. If not, it will drop onto the next line and wait for another header.</p>

<p>If an array is specified then the computer will search for an array on the tape and load it. The array must be large enough to take all the elements of the array being loaded from tape. If not, the message OVERFLOW ERROR will be printed. Also, the type (string or numeric) of the array must match, otherwise the message TYPE MISMATCH ERROR will be printed. The no. of dimensions in the array does not matter, so long as the total number of elements is greater than or equal to the number of elements in the array saved.</p>

<p>When BASIC saves an array it saves the first dimension first, then the next element in the second dimension, etc. For example in an array set to DIM A(3,3) it saves in this order:</p>

<p>A(0,0) , A(1,0) , A(2,0) , A(3,0) , A(0,1) , A(1,1) , A(2,1) , A(3,1) , A(0,2) , A(1,2) , A(2,2) , A(3,2) , A(0,3) , A(1,3) , A(2,3) , A(3,3).</p>

<p>This could be saved from array A and reloaded into array X which had been set to DIM X(15) (although it could have been bigger) and A(0,0) =X(0) and so on. Any additional elements (not loaded from tape) are left unchanged, so for instance A could be loaded into an array with 30 elements and only the first 16 would be changed.</p>

<p>EG LOAD will search for a program, if it is a BASIC program it will RUN.</br>
LOAD @A will search for the first array and load it.</br>
LOAD ("FI*") will search for the program 'FI*'.</p>

<h3>ERRORS</h3>

<p>BASIC will check for any errors occurring during the loading of a file from tape. If any are detected, a question mark (?) is printed on the line below the header of the file being loaded to inform the user of the fact. Only one query will be printed no matter how many errors are detected and BASIC will not abort from the load but wait until the data has been loaded and then print the message LOAD ERROR and return to the command level. It may be that the program has only missed one byte in which case it is only a question of using EDIT to correct the mistake. However, it may be that it has corrupted a pointer or line number, in which case it is best to exit to the monitor with CNT-C and re-enter BASIC with J and try again. (SCR may not work if the program pointers have been corrupted).</p>

<h3>BREAKING</h3>

<p>The SAVE command may be exited at any time by using the break key. Load may be exited whilst it is searching for a file or printing the header, but when a program is loading the RST-2 will have to be used (or RESET) since a break during a file load could corrupt memory.</p>

<h3>BEEP BEEP</h3>

<p>For users with the bleeper circuit fitted (details in documentation components from Transam) the bleeper will sound after a SAVE has finished and after each file has been loaded with LOAD.</p>

<h3>DEBUGGING</h3>

<p>Several commands are available on Level seven to aid in the fast development of programs and the efficient debugging thereof.</p>

<h3>STOP</h3>

<p>This will cause BASIC to print the message BREAK IN LINE x (where x is the line in which stop occurs) and to return to the command level. Execution may be continued from after the STOP by using CONT.</p>

<h3>TRACE</h3>

<p>This command causes BASIC to print all line numbers as they are executed. They are printed in square brackets (to distinguish them) as each line is encountered.</p>

<h3>OFF</h3>

<p>The command OFF will stop the action caused by TRACE. This is the condition at power-on and entry to BASIC by J.</p>

<h3>DUMP</h3>

<p>This is a very useful command. Used to find what's what in a program. It will print all variables used, together with their values (string or numeric). Also arrays are printed with their total size. Note that the dimensions appear in the opposite order to that used in a DIM statement (DIMA(2,3) will give A(3,2) )</p>

<p>here is an example of a dump</p>

<pre>
A=3.14159
A$=HELLO
NA$=GEORGE P. INGLISH
C(5,2)
D$(50,50)
</pre>

<h2>OTHER USEFUL FEATURES</h2>

<h3>SWAP</h3>

<p>Used to swap two variables, strings, array elements etc. Both sides must be of the same type otherwise a TYPE MISMATCH ERROR is generated.</p>

<p>EG SWAP COUNT,C1 SWAP NAME$,TMP$ SWAP A(4,3),A(X,Y) etc.</p>

<h3>ERASE</h3>

<p>Used for removing an array from memory, so that it may be re-dimensioned or may give additional space for other operations. Generally used after a SAVE to save the contents of the array. More than one item may be specified, arrays being separated by commas.</p>

<p>EG ERASE R,Y$</p>

<h3>RANDOMIZE</h3>

<p>Used to set the random number generator at an unpredictable point. Note that the BASIC will always return the same number after entering, but from thereon the result is not predictable (see RND).</p>

<h3>WIDTH</h3>

<p>When BASIC sends its output to a printer the width of the page is assumed to be 64 characters (as on the VDU) but this can be altered by using the WIDTH command, the number following the command is used as the width (0-255)</p>

<p>EG WIDTH 80 will set up for an 80 column printer.</p>

<hr>

<p>That concludes the description of the commands and functions available to the LEVEL SEVEN BASIC user. Other features of the language will now be dealt with, followed by a list of functions and finishing with some tips and hints.</p>

<h3>MATHEMATICAL OPERATIONS</h3>

<p>All arithmetic is carried out on floating point numbers and where possible they are represented in normal format. If they go out of the range of normal representation they are printed in normal scientific format (see previous section). Expressions may be as complex as necessary with the main limitation being the length of a single line. The number of parentheses is not limited, nor are other nested functions and recursive execution is permitted by the stack-orientated structure of the BASIC.</p>

<h3>ARITHMETIC OPERATORS</h3>

<p>The full range of mathematical operators are present (+,-,*,/) which may be used for numeric calculations (+ alone may be used for string concatenation). In addition exponentiation is supported (X to the Y is entered X^Y), in addition comparators and logical operators are allowed (see previous section for priority).</p>

<h3>LOGICAL CAPTAIN</h3>

<p>Logical operators are generally used on IF statements (IF A=B OR B+C=R THEN) but they operate in a logical fashion on signed 16 bit integers; comparators yield either -1 (TRUE) or 0 (FALSE); therefore NOT -1 gives 0. AND, OR, NOT, and XOR all operate on a bitwise principle. Here are some examples:</p>

<p>63 AND 16 =16 63=111111, 16=10000 so giving 16<br>
4 OR 2=6 4=100,2=10 ans =110 =6.<br>
3 XOR 2=1 3=11 ,2=10 ans =001 =1.</p>

<p>For a fuller explanation of logical operations see the book list in the monitor section.</p>

<h3>EASY AS ...</h3>

<p>PI is available as a predefined variable, and may not be redeclared. It has the value 3.1415927 and will yield correct results when used with the trigonometric functions.</p>

<h3>FUNCTIONS</h3>

<p>The functions available on the LEVEL SEVEN are listed below and standard trigonometric functions are handled in radians. The following routine can be used to convert from radians to degrees.</p>

<p>X/PI*180 will give x in degrees X*PI/180 will convert to radians.</p>

<h3>OTHER FUNCTIONS</h3>

<p>The following functions can be calculated by using the formulas given below:</p>

<table>
<tr><td><u>FUNCTION</u></td><td><u>FUNCTION IN BASIC</u></td></tr>
<tr><td>SECANT</td><td>SEC(X) = 1/COS(X)</td></tr>
<tr><td>COSECANT</td><td>CSC(X) = 1/SIN(X)</td></tr>
<tr><td>COTANGENT</td><td>COT(X) = 1/TAN(X)</td></tr>
<tr><td>INVERSE SINE</td><td>ARCSIN(X) = ATN(X/SQR(-X*X+1))</td></tr>
<tr><td>INVERSE COSINE</td><td>ARCCOS(X) = ATN(X/SQR(-X*X+1))+1.5708</td></tr>
<tr><td>INVERSE SECANT</td><td>ARCSEC(X) = ATN(SQR(X*X-1))+(SGN(X)-1)*1.5708</td></tr>
<tr><td>INVERSE COSECANT</td><td>ARCCSC(X) = ATN(1/SQR(X*X-1))+(SGN(X)-1*1.5708</td></tr>
<tr><td>INVERSE COTANGENT</td><td>ARCCOT(X) = -ATN(X)+1.5708</td></tr>
<tr><td>HYPERBOLIC SINE</td><td>SINH(X) = (EXP(X)-EXP(-X))/2</td></tr>
<tr><td>HYPERBOLIC COSINE</td><td>COSH(X) = (EXP(X)+EXP(-X))/2</td></tr>
<tr><td>HYPERBOLIC TANGENT</td><td>TANH(X) = -EXP(-X)/(EXP(X)+EXP(-X))*2+1</td></tr>
<tr><td>HYPERBOLIC SECANT</td><td>SECH(X) = 2/(EXP(X)+EXP(-X))</td></tr>
<tr><td>HYPERBOLIC COSECANT</td><td>CSCH(X) = 2/(EXP(X)-EXP(-X))</td></tr>
<tr><td>HYPERBOLIC COTANGENT</td><td>COTH(X) = EXP(-X)/(EXP(X)-EXP(-X))*2+1</td></tr>
<tr><td>INV. HYPERBOLIC SINE</td><td>ARGSINH(X) = LOG(X+SQR(X*X+1))</td></tr>
<tr><td>INV. HYPERBOLIC COSINE</td><td>ARGCOSH(X) = LOG(X+SQR(X*X-1))</td></tr>
<tr><td>INV. HYPERBOLIC TANGENT</td><td>ARGTANH(X) = LOG((1+X)/(1-X))/2</td></tr>
<tr><td>INV. HYPERBOLIC SECANT</td><td>ARGSECH(X) = LOG((SQR(-X*X+1)+1)/X)</td></tr>
<tr><td>INV. HYPERBOLIC COSEC.</td><td>ARGCSCH(X) = LOG((SGN(X)*SQR(X*X+1)+1)/X</td></tr>
<tr><td>INT. HYPERBOLIC COTAN.</td><td>ARGCOTH(X) = LOG((X+1)/(X-1))/2</td></tr>
</table>

<h3>INTRINSIC BASIC FUNCTIONS</h3>

<table>
<tr valign="top"><td>ABS(X)</td><td>Gives the absolute value of X. (X may be a constant, variable or expression). Will return X if X =0, -X otherwise.</td></tr>
<tr valign="top"><td>INT(X)</td><td>Returns the largest integer less than or equal to X.<br>EG INT(.85)=0 1.9 = 1 -3.1 = -4 etc..<br>To round a number add .5<br>EG to round a number X to D decimal places use:<br><pre>PRINT INT(X*1^D+.5)/10^D</pre></td></tr>
<tr valign="top"><td>RND(X)</td><td>Will return a random number between 0 and 1 (sometimes 0 never 1), if X'0 the last number is returned, otherwise a new number is returned.<br>(B-A)*RND(1)+A will generate a number from A to B.</td></tr>
<tr valign="top"><td>SGN(X)</td><td>Gives +1 if X&gt;0, 0 if X=0, -1 if X&lt;0.</td></tr>
<tr valign="top"><td>SIN(X)</td><td>Gives the sine of X in radians.</td></tr>
<tr valign="top"><td>COS(X)</td><td>Gives the cosine of X.</td></tr>
<tr valign="top"><td>TAN(X)</td><td>Gives the tangent of X.</td></tr>
<tr valign="top"><td>ATN(X)</td><td>Gives the arctangent of X.</td></tr>
<tr valign="top"><td>EXP(X)</td><td>Gives the constant E (2.71828) raised to the power X. The largest value X may take is 87.3365.</td></tr>
<tr valign="top"><td>LOG(X)</td><td>Gives the natural (base E) logarithm of X.<br>LOG(X)/LOG(Y) gives the base Y logarithm of X.<br>EG common (base 10) log of 5 is LOG(5)/LOG(10)</td></tr>
<tr valign="top"><td>FRE(X)</td><td>Gives the number of free (unused bytes) left for the program if the expression X is numeric or the number of free bytes for strings if the expression is string.<br>EG FRE(0) or FRE(A$)</td></tr>
<tr valign="top"><td>PEEK(X)</td><td>Returns the value held in the location X in memory.</td></tr>
<tr valign="top"><td>INP(X)</td><td>Returns the value currently at port X (X must be 0-255)</td></tr>
</table>

<h3>STRING FUNCTIONS</h3>

<table>
<tr valign="top"><td>ASC(X$)</td><td>Returns a single ASCII character as its numeric value EG if X$="?" then ASC($) would give 63. If the string is longer than one character the first character is used if the string is null ("") an error will occur.</td></tr>
<tr valign="top"><td>CHR$(X)</td><td>Returns a single character whose ASCII value is X (for ASCII codes see the TRITON manual).</td></tr>
<tr valign="top"><td>STRING$(X,Y)</td><td>Returns a string X characters long of character Y.</td></tr> 
<tr valign="top"><td>STR$(X)</td><td>Gives a string equal to the value X as it would be printed by a PRINT statement<br>EG STR$ (2+3.5) would give "5.5"</td></tr>
<tr valign="top"><td>VAL</td><td>Used to convert a numeric string to a number.<br>EG VAL("5.5") gives 5.5<br>If the first character is not +,-,$ or a number the value 0 is returned.</td></tr>
<tr valign="top"><td>LEN(X$)</td><td>Returns the length of string X$. If X$ is null 0 is returned.</td></tr>
<tr valign="top"><td>LEFT$(X$,Y)</td><td>Returns the Y leftmost characters in X$. If Y is greater than the number of characters in X$ (LEN(X$)) X$ is returned.</td></tr>
<tr valign="top"><td>RIGHT$(X$,Y)</td><td>Returns the Y rightmost characters in X$. If Y&gt;=LEN(XS) X$ is returned.</td></tr>
<tr valign="top"><td>MID$(X$,Y)</td><td>MID$ with 2 arguments returns a string from character Y to the end of X$. If Y>LEN(X$) a null string is returned.</td></tr>
<tr valign="top"><td>MID$(X$,Y,Z)</td><td>Returns a string from character Y in X$ for Z characters. If Y>LEN(X$) a null string is returned.</td></tr>
<tr valign="top"><td>INSTR(X$,Y$,Z)</td><td>Returns the position of the first occurance of Y$ within X$ starting at position Z in X$ (Z is optional) If Y$ is not in X$ or either of the strings are null a value of 0 is returned.<br>EG IF INSTR(ANS$,"YES")THEN PRINT "I AGREE"</td></tr>
</table>

<hr>

<h3>ERROR MESSAGES</h3>

<p>The following is a list of error messages with possible causes and fixes.</p>

<p>Error messages are in two forms, the first which occurs during an immediate command takes the form</p>

<pre>XXXX ERROR</pre>

<p>Where XXXX is the error message, the second form occurs during execution and takes the form</p>

<pre>XXXX ERROR IN LINE YYY</pre>

<p>Where YYY is the line number of the line in which the error occured.</p>

<h3>SYNTAX ERROR</h3>

<p>This is the most common error and indicates a mistake such as missing braket or an incorrect character; once found is easy to fix.</p>

<h3>BAD SUBSCRIPT ERROR</h3>

<p>Occurs when referencing an element not in that particular array; may also be due to too many or too few dimensions being specified.</p>

<p>EG an attempt to reference A(1,1,1) when A was dimensioned as A(2,2).</p>

<h3>REDIMENSION ERROR</h3>

<p>An attempt was made to DIMension an array that had already been dimensioned. Can also occur if an array was not dimensioned before it is referenced (see section of DIM statement).</p>

<p>EG A(3)=2 is encountered before DIM A(100).</p>

<h3>BAD ARGUMENT ERROR</h3>

<p>Another common error, due to the argument for a function or statement being out of range. Some common causes are:</p>

<ol><li>a negative argument for a subscript E,G, LET C(-1)=3</li>
<li>an unreasonably large subscript (>32767)</li>
<li>LOG negative or zero argument.</li>
<li>SQR negative argument</li>
<li>a reference to CALL,INSTR,MID$,LEFT$,RIGHT$,STRING$,INP,OUT,PEEK,POKE,TAB,SPC,VDU,ON..GOTO or ON..GOSUB,with an improper argument.</li>
</ol>

<h3>DIRECT ERROR</h3>

<p>Occurs if you try to use DEF or INPUT or LINE INPUT as a direct command. Whilst these cannot be used, other commands are pointless when used as direct statements (REM,DATA,etc..).</p>

<h3>MISSING FOR ERROR</h3>

<p>A NEXT statement was encountered without a corresponding FOR.</p>

<h3>MISSING GOSUB ERROR </h3>

<p>A RETURN statement was encountered before a GOSUB.</p>

<h3>MISSING LINE ERROR</h3>

<p>An attempt was made to reference a line which does not exist in memory. Can occur on the following statements.</p>

<p>GOTO,GOSUB,RUN,RESTORE,THEN,ELSE or EDIT.</p>

<h3>OVERFLOW ERROR</h3>

<p>The overflow error has a general meaning and two specific meanings. The specifics will be dealt with first.</p>

<ol><li>The line specified in EDIT was too long to fit in the buffer.</li>
<li>The line number being calculated by AUTO got too large.</li>
<li>The result of a calculation was too large to be stored or printed. If a number underflows the result 0 is given with no error.</li>
</ol>

<h3>NO SPACE ERROR</h3>

<p>Program too large, too many GOSUBs, too many F0Rs too many levels of parentheses or too complex an expression or any combination of the above, the amount of space can be increased by decreasing the size of the CLEAR command (if used).</p>

<h3>NO STRING SPACE ERROR</h3>

<p>The space left for strings was less than the length of the string being stored; more space can be reserved by using a CLEAR statement or one with a larger argument (may conflict with above).</p>

<h3>MISSING DATA ERROR</h3>

<p>A read was encountered without any corresponding DATA statements or all the data had been used. A RESTORE statement can be used to re-read the data or extra DATA statements added.</p>

<h3>MISSING FUNCTION ERROR </h3>

<p>An attempt was made to use a user function which had not been defined.</p>

<h3>DIVIDE ERROR</h3>

<p>An attempt was made to divide by 0 (can occur if the TAN(PI/2) is attempted.)</p>

<h3>CONT ERROR</h3>

<p>An attempt was made to execute a CONT command after an error had occurred or the program was modified.</p>

<h3>STRING OVERFLOW ERROR</h3>

<p>The length of a string exceeded 255 characters.</p>

<h3>STRING ARGUMENT ERROR</h3>

<p>A string argument was too complex, split the expression into two or more shorter parts.</p>

<h3>TYPE MISMATCH ERROR</h3>

<p>The right and left hand parts of an expression must be of the same type (string or numeric) or an attempt was made to supply a function with the wrong type of data.</p>

<h3>LOAD ERROR</h3>

<p>The tape load program detected a read error, the program was still loaded and may be corrected, or an attempt made to re-load.</p>

<h3>SAVING SPACE</h3>

<ol>
<li>Use multiple statement lines, each line has a fixed overhead of 5 bytes, therefore each line combined is 5 bytes saved.</li>
<li>Delete all REM statements, each character in a rem statement uses one byte (including spaces).<br>EG 130 REM THIS IS A COMMENT uses 23 bytes.<br>210 PRINT RES :REM PRINT SUM uses 11 bytes including the colon.</li>
<li>Use variables instead of constants C uses one byte 5.3246 uses 6. This also improves the speed of a program.</li>
<li>The END statement is optional and can be omitted to save space.</li>
<li>Reuse variables. A variable once declared uses space and if a temporary variable is used in one part of a program use it again in another. Also use one temporary variable for user replies.</li>
<li>Use GOSUBs to execute common portions of code.</li>
<li>Use User FUNCTIONS for common expressions.</li>
<li>USE the zero elements in arrays. EG A(0) B(0,0) etc..</li>
</ol>

<h3>STORAGE ALOCATION</h3>

<p>Simple (non array) variables use 6 bytes; a string variable uses 6 bytes of main store plus one byte per character in the actual string in the string store.</p>

<p>Matrices use a minimum of 12 bytes with elements using 4 bytes each plus 2 bytes for every dimension.</p>

<p>A user function uses 6 bytes.</p>

<p>Each keyword (PRINT,SAVE,LIST,TAN etc) uses one byte; other characters use 1 byte each (spaces are not stored except in REMs).</p>

<p>Each active FOR..NEXT loop uses 22 bytes.</p>

<p>Each active GOSUB (one that hasn't returned) uses 6 bytes.</p>

<p>Each parentheses encountered uses 4 bytes and each temporary result calculated uses 12 bytes.</p>

<h3>SPEED HINTS</h3>

<p>The hints given below will increase the execution speed and in many cases reduce storage requirements as well.</p>

<ol><li>Delete all REM statements; these slow BASIC down by having to ignore them.</li>
<li>USE VARIABLES INSTEAD OF CONSTANTS - THIS WILL INCREASE SPEED BY A LARGE AMOUNT. It is much faster to recall the value of a variable then work out the value of a stored number in ASCII.</li>
<li>Variables used often should be declared at the start of the program. The first variable declared will be the quickest to find.</li>
<li>Use NEXT without an index variable, BASIC does not need to check for the correct index.</li>
</ol>

</body></html>
